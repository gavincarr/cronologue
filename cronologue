#!/usr/bin/perl
#
# Script to record cron job execution and archive output back to a 
# central webserver as text files using HTTP PUTs.
#

use strict;
use warnings;
use File::Basename;
use Getopt::Long qw(:config no_ignore_case bundling require_order);
use Config::Tiny;
use Sys::Hostname;
use Time::Piece;
use Digest::MD5 qw(md5_hex);
use IPC::Run qw(harness);
use LWP::UserAgent;
use HTTP::Request;

sub usage {
  die "usage: " . basename($0) . " <command> <args>\n";
}

my $verbose = 0;
my ($help, $noop);
usage unless GetOptions(
  'help|h|?'        => \$help,
  'verbose|v+'      => \$verbose,
  'noop|n'          => \$noop,
);
usage if $help;
usage unless @ARGV;
$verbose ||= 1 if $noop;

# If a single composite argument, treat as a string
my @cmd = @ARGV;
my $cmd = @cmd == 1 && $cmd[0] =~ m/\s/ ? $cmd[0] : \@cmd;

# Setup a die handler to just exec the given args on error
local $SIG{__DIE__} = sub { 
  die @_ if $^S;        # but don't exec inside an eval
  warn @_;
  exec @cmd;
};

# Setup config etc.
my $config_file = $ENV{CRONOLOGUE_CONF} || "/etc/cronologue.conf";
my $config = Config::Tiny->read($config_file) if -f $config_file;
my $server = $config->{_}->{cronologue_server} || 'localhost';
my $hostname = hostname;
(my $hostname_short = $hostname) =~ s/\..*$//;
my $user = getpwuid($>) || $>;
my $start = gmtime;
my $start_ts   = $start->strftime('%Y%m%d%H%M%S');
my $start_long = $start->strftime('%a %d %b %Y %H:%M:%S');
my $start_date = $start->strftime('%Y-%m-%d');
my $start_time = $start->strftime('%H:%M:%S');
my $cmdline = join ' ', @cmd;
my $cmd_basename = basename($cmd[0]);
my $cmd_digest = md5_hex $cmdline;

# Build base URL
my $host_url = sprintf "http://%s/cronologue/data/", $server;
my $url_path = sprintf "%s/%s_%s", $hostname_short, $start_ts, $cmd_digest;

# Build initial output
my $record = <<EOD
Hostname:       $hostname_short
FQDN:           $hostname
Username:       $user
StartDatetime:  $start_long
StartDate:      $start_date
StartTime:      $start_time
CommandLine:    $cmdline
Command:        $cmd_basename
CommandDigest:  $cmd_digest
EOD
;

my $ua = LWP::UserAgent->new;
$ua->env_proxy;

# Do a MKCOL on the top-level $host_url, if required
my $url = "$host_url$hostname_short/";
my $req = HTTP::Request->new( GET => $url );
my $res = $ua->request($req);
if ($res->code == 404) {
  print "+ host url $url not found - doing MKCOL\n" if $verbose;
  unless ($noop) {
    $req = HTTP::Request->new( MKCOL => $url );
    $res = $ua->request($req);
    die "MKCOL to $url failed: " . $res->status_line unless $res->is_success;
  }
}

# PUT initial job record
my $job_url = "$host_url$url_path.txt";
print "+ job record url: $job_url\n" if $verbose;
unless ($noop) {
  $req = HTTP::Request->new( PUT => $job_url );
  $req->content_type('text/plain');
  $req->content($record);
  $res = $ua->request($req);
  die "PUT to $job_url failed: " . $res->status_line unless $res->is_success;
}

# Run command
my $stdout = 'x' x 10_000; $stdout = '';        # preallocate 10k bytes
my $stderr = 'x' x 10_000; $stderr = '';        # preallocate 10k bytes
my $h = harness \@cmd, \undef, \$stdout, \$stderr;
$h->run;
my $rc = $h->result(0);
my $end = gmtime;
my $end_ts   = $end->strftime('%Y%m%d%H%M%S');
my $end_long = $end->strftime('%a %d %b %Y %H:%M:%S');
my $end_date = $end->strftime('%Y-%m-%d');
my $end_time = $end->strftime('%H:%M:%S');
my $runtime  = $end - $start;

# PUT stdout and stderr, if any
my $stdout_stderr = '';
if ($stdout ne '') {
  my $stdout_path = "$url_path.out";
  $stdout_stderr .= "Stdout:         $stdout_path\n";
  $stdout_stderr .= "StdoutSize:     " . length($stdout) . "\n";
  $url = $host_url . $stdout_path;
  print "+ stdout found, url: $url\n" if $verbose;
  unless ($noop) {
    $req = HTTP::Request->new( PUT => $url );
    $req->content_type('text/plain');
    $req->content($stdout);
    $res = $ua->request($req);
    die "PUT to $url failed: " . $res->status_line unless $res->is_success;
  }
}
if ($stderr ne '') {
  my $stderr_path = "$url_path.err";
  $stdout_stderr .= "Stderr:         $stderr_path\n";
  $stdout_stderr .= "StderrSize:     " . length($stderr) . "\n";
  $url = $host_url . $stderr_path;
  print "+ stderr found, url: $url\n" if $verbose;
  unless ($noop) {
    $req = HTTP::Request->new( PUT => $url );
    $req->content_type('text/plain');
    $req->content($stderr);
    $res = $ua->request($req);
    die "PUT to $url failed: " . $res->status_line unless $res->is_success;
  }
}

$record = <<EOD
Hostname:       $hostname_short
FQDN:           $hostname
Username:       $user
StartDatetime:  $start_long
StartDate:      $start_date
StartTime:      $start_time
EndDatetime:    $end_long
EndDate:        $end_date
EndTime:        $end_time
JobDuration:    $runtime
CommandLine:    $cmdline
Command:        $cmd_basename
CommandDigest:  $cmd_digest
ReturnCode:     $rc
$stdout_stderr
EOD
;

# PUT updated job record
print "+ job record url: $job_url\n" if $verbose;
print "+ job record:\n$record" if $verbose >= 2 or $noop;
unless ($noop) {
  $req = HTTP::Request->new( PUT => $job_url );
  $req->content($record);
  $res = $ua->request($req);
  die "PUT to $job_url failed: " . $res->status_line unless $res->is_success;
}

# vim:sw=2
