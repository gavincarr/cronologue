# Blosxom Plugin: entries_cache_metamail
# Author(s): Gavin Carr <gavin@openfusion.com.au>
# Version: 0.001000
# Documentation: See the bottom of this file or type: perldoc entries_cache_metamail

use Blosxom::Include qw(entries_cache_metamail);

package entries_cache_metamail;

use strict;
use File::stat;
use File::Find;
use Data::Dumper;
use Time::Piece;
use CGI ();

# Uncomment next line to enable debug output (don't uncomment debug() lines)
#use Blosxom::Debug debug_level => 2;

my %config = ();

# --- Configurable variables -----

# Where should I store the entries_cache_metamail index file?
# IMO timestamps are metadata rather than state, but you may well not care.
$config{meta_dir} = $blosxom::plugin_state_dir;
#$config{meta_dir} = "$blosxom::datadir/../meta";

# What name should my entries_cache_metamail index file be called?
$config{index_filename} = 'entries_cache_metamail.index';

# How long should the cached index be used before rechecking (seconds)
# (Zero means recheck every time)
$config{cache_period} = 900;
#$config{cache_period} = 0;

# Reindexing password. If entries_cache_metamail finds a '?reindex=$reindex_password'
# parameter it will bypass the cache and recheck all timestamps
$config{reindex_password} = 'abracad';    # CHANGEME!

# Whether to follow symlinks in posts directory
$config{follow_symlinks} = 0;

# Metamail metadata header to check for post timestamp, overriding mtime if set
$config{post_timestamp_header} = '';
#$config{post_timestamp_header} = 'Date';

# Post timestamp strptime(1) format (required if post_timestamp_header set)
$config{post_timestamp_format} = '';
#$config{post_timestamp_format} = '%Y-%m-%d';
#$config{post_timestamp_format} = '%Y-%m-%d %T';

# --------------------------------
# __END_CONFIG__

use vars qw($DATA $UPDATES);

sub start { 1 }

sub entries {
  return sub {
    $UPDATES = 0; 
    $DATA = {};
    my $q = CGI->new;
    my %indexes;

    # Read $config{index_filename}
    my $index_path = "$config{meta_dir}/$config{index_filename}";
    if (-f $index_path) {
      open my $fh, '<', $index_path
        or die "(entries_cache_metamail) cannot open index file '$index_path': $!";
      my $index;
      { local $/; $index = <$fh> }
      close $fh;

      die "(entries_cache_metamail) index file '$config{meta_dir}/$config{index_filename}' corrupted?"
        unless $index =~ m/\$DATA = \{/;

      # Eval into local namespace
      # First eval catches failures, second evals into our namespace
      eval { eval $index } 
        or die "(entries_cache_metamail) eval of $index_path failed: $@";
    }
    $DATA->{symlinks} ||= {};

    # Check whether to reindex
    my $now = time;
    my $force_reindex = 0;
    if (my $reindex = $q->param('reindex') and $config{reindex_password}) {
      if ($reindex eq $config{reindex_password}) {
        $force_reindex = 1;
        warn "(entries_cache_metamail) reindex forced via reindex query parameter\n";
      }
      else {
        warn "(entries_cache_metamail) Warning: reindex requested with incorrect password\n";
      }
    }
    if ($force_reindex || 
        $blosxom::static_or_dynamic eq 'static' ||
        $now - ($DATA->{index_mtime}||0) > $config{cache_period}) {

      # Check for deleted files
      for my $file (keys %{$DATA->{timestamps}}) { 
        if ( ! -f $file || ( -l $file && ! -f readlink($file)) ) {
          $UPDATES++; 
          delete $DATA->{timestamps}->{$file};
          delete $DATA->{symlinks}->{$file};
          # debug(2, "deleting removed file '$file' from indexes");
        } 
      }

      # Check for new files
      my $param_all = $q->param('-all');
      find(
        {
          follow => $config{follow_symlinks},
          wanted => sub {
            my $curr_depth = $File::Find::dir =~ tr[/][]; 
            if ( $blosxom::depth and $curr_depth > $blosxom::depth ) {
              delete $DATA->{timestamps}->{$File::Find::name};
              delete $DATA->{symlinks}->{$File::Find::name};
              return;
            }
        
            # Return unless this is a post file
            return unless $File::Find::name =~ 
              m! ^$blosxom::datadir/(?:(.*)/)?(.+)\.$blosxom::file_extension$ !x;
            my $path = $1;
            my $filename = $2;
            # Return if an index, a dotfile, or unreadable
            if ( $filename eq 'index' or $filename =~ /^\./ or ! -r $File::Find::name ) {
              # debug(1, "(entries_cache_metamail) '$path/$filename.$blosxom::file_extension' is an index, a dotfile, or is unreadable - skipping\n");
              return;
            }

            # If a new symlink, add to $DATA->{symlinks}
            my $mtime;
            if ( -l $File::Find::name ) {
              if ( ! exists $DATA->{symlinks}->{ $File::Find::name } ) {
                $mtime = stat($File::Find::name)->mtime;
                $DATA->{symlinks}->{$File::Find::name} = 1;
                $UPDATES++;
                # debug(2, "new symlinks entry $File::Find::name, UPDATES now $UPDATES");
              }
            }

            # Non-symlinks
            else {
              # For existing files, only recheck if latest mtime has changed
              if (my $entry = $DATA->{timestamps}->{$File::Find::name}) {
                my $file_mtime = stat($File::Find::name)->mtime;
                if ($file_mtime > $entry->{latest}) {
                  $entry->{latest} = $file_mtime;
                  $entry->{metadata} = extract_post_timestamp_header(
                    $File::Find::name, $config{post_timestamp_header}, $config{post_timestamp_format}
                  );
                  $UPDATES++;
                  # debug(2, "rechecked existing file entry $File::Find::name, UPDATES now $UPDATES");
                }
                $mtime = $entry->{metadata} || $entry->{original};
              }

              # If a new file, add to $DATA->{timestamps}
              else {
                $mtime = stat($File::Find::name)->mtime;
                my $metadata_mtime = '';
                if ($config{post_timestamp_header} && $config{post_timestamp_format}) {
                  $metadata_mtime = extract_post_timestamp_header(
                    $File::Find::name, $config{post_timestamp_header}, $config{post_timestamp_format}
                  );
                }
                $DATA->{timestamps}->{$File::Find::name} = { 
                  original => $mtime, latest => $mtime, metadata => $metadata_mtime,
                };
                $UPDATES++;
                # debug(2, "new file entry $File::Find::name, UPDATES now $UPDATES");
              }
            }
            
            # Static rendering
            if ($blosxom::static_or_dynamic eq 'static') {
              # Ignore if future unless $show_future_entries is set
              return unless $blosxom::show_future_entries or $mtime <= $now;

              my $static_file = "$blosxom::static_dir/$path/index.$blosxom::static_flavours[0]";
              if ($param_all
                  or ! -f $static_file
                  or stat($static_file)->mtime < $mtime ) {
                # debug(3, "static_file: $static_file");
                $indexes{$path} = 1;
                if ($blosxom::static_date_pages) {
                  my @nice_date = blosxom::nice_date( $mtime );
                  my $d = join('/', @nice_date[5,2,3]);
                  $indexes{$d} = $d;
                }
                $path = $path ? "$path/" : '';
                $indexes{ "$path$filename.$blosxom::file_extension" } = 1
                  if $blosxom::static_entries;
              }
            }
          }
        }, $blosxom::datadir
      );
    }

    # Generate blosxom %files from $timestamps and $symlinks
    my %files;
    for (keys %{$DATA->{timestamps}}) {
      my $entry = $DATA->{timestamps}->{$_};
      my $mtime = $entry->{metadata} || $entry->{original};

      # Ignore if future unless $show_future_entries is set
      next unless $blosxom::show_future_entries or $mtime <= $now;

      $files{$_} = $mtime;
    }
    for (keys %{$DATA->{symlinks}}) {
      # Add to %files with mtime of referenced file
      my $target = readlink $_;
      # Note that we only support symlinks pointing to other posts
      $files{$_} = $files{ $target } if exists $files{ $target };
    }

    return (\%files, \%indexes);
  };
}

# Extract post_timestamp_header from story_file, if present, and return as epoch value.
# Would be nice to do this at story hook time when the post file is already open, but
# blosxom only calls story hooks for the first (sorted) $num_entries posts, and we need 
# to have the mtime to determine how to do the sorting in the first place.
sub extract_post_timestamp_header {
  my ($story_file, $post_timestamp_header, $post_timestamp_format) = @_;
  return unless $post_timestamp_header;
  die "(entries_cache_metamail) post_timestamp_format not set - required if using post_timestamp_header\n"
    unless $post_timestamp_format;

  # debug(2, "checking $post_timestamp_header header in $story_file");
  open my $fh, '<', $story_file
    or die "(entries_cache_metamail) failed to open post '$story_file': $!";
  my $linecount = 1;
  while (my $header = <$fh>) {
    last if $header =~ m/^\s*$/;
    next unless $header =~ m/^ $post_timestamp_header : \s* (.*?) \s* $/x ||
               (lc $post_timestamp_header eq 'title' && $linecount == 1 &&
                $header =~ m/^ \s* (.*?) \s* $/x);
    # debug(2, "found $post_timestamp_header header in $story_file, timestamp is '$1'");
    if (my $t = eval { Time::Piece->strptime($1, $post_timestamp_format) }) {
      return $t->epoch;
    }
    else {
      warn "(entries_cache_metamail) post_timestamp_header $post_timestamp_header '$1' not in " .
        "format '$post_timestamp_format' - ignoring\n";
    }
  }
  continue {
    $linecount++;
  }
  close $fh;

  return '';
}

# Save index if we've made any updates
sub end {
  # If we have updates, save back to index
  if ($UPDATES) {
    # debug(1, "$UPDATES updates, saving indices to $config{meta_dir}/$config{index_filename}");
    if ( open my $fh, ">", "$config{meta_dir}/$config{index_filename}" ) {
      $DATA->{index_mtime} = time;
      print $fh Data::Dumper->Dump([ $DATA ], [ 'DATA' ]);
      close $fh;
    }
    else {
      warn "(entries_cache_metamail) couldn't open $config{meta_dir}/$config{index_filename} for writing: $!\n";
    }
  }

  return 1;
}

1;

__END__

=head1 NAME

entries_cache_metamail: blosxom plugin to allow timestamping bloxom posts 
either from the original creation time on the post or from an arbitrary 
metadata header

=head1 SYNOPSIS

entries_cache_metamail is a blosxom plugin to allow capturing, preserving, 
and caching timestamps on blosxom posts, either from the original post mtime, 
or from an arbitrary metadata header. It is derived from Rael Dornfest's 
original L<entries_index> plugin, maintains a similar (but incompatible) 
index file to entries_index, and provides a custom entries subroutine for blosxom.

It differs from L<entries_index> as follows:

=over 4

=item Metadata support

Timestamps can be sourced from metadata headers in addition to the original
mtime on the post file. Metadata support requires the L<metamail> plugin
(and is currently incompatible with Rael's L<meta> plugin), and the
L<post_timestamp_header> and L<post_timestamp_format> config options to be
set. Both are empty by default.

=item Caching

The entries_cache_metamail index file also behaves as a cache, and 
entries_cache_metamail only checks for new, updated, and deleted posts 
every L<cache_period> seconds (default: 900 i.e. 15 minutes). 
entries_cache_metamail also supports a L<reindex_password> setting, so 
that reindexing can be forced by passing a ?reindex=<reindex_password> 
parameter on a blosxom request.

=item Separate symlink handling

entries_cache_metamail uses separate indexes for posts that are files and
posts that are symlinks, and doesn't bother to cache timestamps for
the latter at all, deriving them instead from the post they point to.
(Note that this means entries_cache_metamail doesn't support symlinks to 
non-post files at all - they're just ignored).

=item Configurable index file name and location

I consider post timestamps to be metadata rather than state, so I 
tend to use a separate C<meta> directory alongside by posts for this,
rather than the traditional $plugin_state_dir. You may not care. ;-)

=item A complete rewrite

Completely rewritten code, since the original used evil evil and-chains 
and was pretty difficult to understand (IMHO).

=back

=head1 SEE ALSO

L<entries_index>, L<entries_cache>, L<entries_cache_meta>

Blosxom Home/Docs/Licensing: http://blosxom.sourceforge.net/

=head1 ACKNOWLEDGEMENTS

Originally based on Rael Dornfest's original L<entries_index> plugin.

=head1 BUGS AND LIMITATIONS

entries_cache_metamail currently only supports symlinks to local post files,
not symlinks to arbitrary files outside your $datadir.

Please report bugs either directly to the author or to the blosxom 
development mailing list: <blosxom-devel@lists.sourceforge.net>.

=head1 AUTHOR

Gavin Carr <gavin@openfusion.com.au>, http://www.openfusion.net/

=head1 LICENSE

Copyright 2010, Gavin Carr.

This plugin is licensed under the same terms as blosxom itself i.e.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

=cut

# vim:ft=perl
